{"version":3,"file":"js/953.f0070f86.js","mappings":"oJAAIA,EAAQC,E,sBCKZ,GACAC,KAAAA,OACAC,OAAAA,CAAAA,EAAAA,EAAAA,EAAAA,GACAC,KAAAA,WACA,OACAC,cAAAA,GACAC,YAAAA,GACAC,gBAAAA,CACA,UACA,UACA,UACA,YACA,aAEAC,KAAAA,EAEA,EACAC,WAAAA,CAAAA,EACAC,QAAAA,CACAC,wBAAAA,CAAAA,EAAAA,GACA,SAIA,KACA,4BACA,WACA,cACAC,EAAAA,EAAAA,QAAAA,IAEAA,EAAAA,EAAAA,QAAAA,KAAAA,EACA,CAKA,gBACA,mBACA,MAIA,WACA,KACA,4BAIA,WACA,UACA,MACA,MACA,2BACAC,EAAAA,KAAAA,CACAC,EAAAA,EAAAA,GACAC,EAAAA,EAAAA,GACAC,EAAAA,EAAAA,IAGA,CAKAH,EAAAA,MAAAA,SAAAA,EAAAA,GACA,cACA,IAKA,UACA,MAEA,IACA,KACA,KAEA,4BACA,WACA,IAaA,GAXA,MACAI,EAAAA,KAAAA,IAAAA,EAAAA,EAAAA,IAGA,OACAC,QAAAA,MAAAA,cAAAA,EAAAA,EAAAA,GAMA,cACA,wBACA,oBAEA,aACAC,EAAAA,GAAAA,CAAAA,GAEA,gBACAA,EAAAA,GAAAA,GAAAA,GAEAA,EAAAA,GAAAA,IAAAA,EAEAX,EAAAA,KAAAA,IAAAA,EAAAA,EAAAA,GAAAA,GACA,CAEAY,EAAAA,EAAAA,CACA,CAEAC,EAAAA,GAAAA,CACAb,IAAAA,EACAc,OAAAA,KAAAA,cAAAA,GAEA,MACAJ,QAAAA,MAAAA,uBAAAA,EAEA,CAEA,QACA,EAMAK,wBAAAA,CAAAA,EAAAA,EAAAA,GAGA,IAFA,SACA,KACA,oBACA,WAEA,wBACA,wBACA,oBACA,WACA,aACAJ,EAAAA,GAAAA,CAAAA,GAEA,gBACAA,EAAAA,GAAAA,GAAAA,GAEAA,EAAAA,GAAAA,KAEAX,EAAAA,KAAAA,IAAAA,EAAAA,EAAAA,GAAAA,IAEA,CACA,CAEA,OACAA,IAAAA,EACAc,OAAAA,KAAAA,cAAAA,GAEA,EAKAE,aAAAA,CAAAA,GACA,SACA,gBACA,WACA,gBACA,SACAC,EAAAA,GAAAA,EACAA,EAAAA,GAAAA,EACAA,EAAAA,GAAAA,EAAAA,GAAAA,GACArB,EAAAA,KAAAA,EACA,CACA,CACA,QACA,EAEAsB,WAAAA,UACA,YACA,EAMAC,KAAAA,SAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,GAEA,kBAIA,cACA,iDAEA,YACA,oCAGAC,EAAAA,UAAAA,EAAAA,EAAAA,EAAAA,GAGA,iCACAC,EAAAA,EAAAA,GACAD,EAAAA,YAAAA,KAAAA,IACAC,EAAAA,GAAAA,OACAC,IAAAA,EAAAA,IAAAA,GAEAF,EAAAA,UAAAA,KAAAA,QAAAA,EAAAA,GAAAA,KAAAA,GAAAA,EAAAA,GAAAA,KAAAA,IAIA,8BACA,kCACAA,EAAAA,aAAAA,EAAAA,EAAAA,EAxBA,CAyBA,EAEAG,OAAAA,SAAAA,EAAAA,GACAC,EAAAA,GAAAA,GAGA,oDACA,qBACA,cAaA,OAXAC,EAAAA,MAAAA,EAAAA,OAAAA,EAAAA,EAEAL,EAAAA,cAAAA,EAAAA,cAAAA,IACAA,EAAAA,WAAAA,EACAA,EAAAA,YAAAA,QAEAA,EAAAA,YACAA,EAAAA,IAAAA,EAAAA,IAAAA,EAAAA,IAAAA,EAAAA,EAAAA,EAAAA,KAAAA,IAAAA,GACAA,EAAAA,YACAA,EAAAA,OAEA,IACA,EAEAM,SAAAA,SAAAA,GAEA,uCACA,qBACA,oCAKA,aAHAC,EAAAA,MAAAA,EACAA,EAAAA,OAAAA,IAEA,EACAD,EAAAA,aAAAA,EAAAA,EAAAA,EAAAA,IAQA,OALAN,EAAAA,UAAAA,EACAA,EAAAA,SAAAA,EAAAA,EAAAA,EAAAA,KAEA,0CAEA,IACA,EAEAQ,UAAAA,SAAAA,EAAAA,GACA,kCACAC,EAAAA,EAAAA,EAAAA,GAEA,IACAC,EAAAA,EAAAA,GAAAA,EAAAA,GACAA,EAAAA,EAAAA,GAAAA,EAAAA,EAAAA,GACAA,EAAAA,EAAAA,GAAAA,EAAAA,EAAAA,GAGA,EAMAC,gCAAAA,CAAAA,EAAAA,EAAAA,GAIA,SACA,oBACAlB,EAAAA,GAAAA,EAEA,QAEA,KACA,KACA,4BACA,WAUA,GARA,yBACAmB,GAAAA,EACAC,GAAAA,GAMA,gDACA,QAMA,GALA,oDACAC,EAAAA,EAAAA,EAAAA,MAAAA,MACAA,EAAAA,KAAAA,MAAAA,EAAAA,IAGA,WAMA,IAFA,eAEA,aACA,UACA,MACArB,EAAAA,IAAAA,EACAb,EAAAA,KAAAA,IAAAA,EAAAA,EAAAA,IAEA,CAEAgC,EAAAA,EAAAA,KACAC,EAAAA,CACA,CACA,CAEA,OACAjC,IAAAA,EACAc,OAAAA,EAEA,EAEAqB,kCAAAA,CAAAA,EAAAA,EAAAA,GAIA,SACA,oBACAtB,EAAAA,GAAAA,EAEA,QAUA,WACA,KACA,4BACA,WAIA,mDACA,yBACAuB,EAAAA,EAAAA,GACA,OACAC,EAAAA,GAAAA,IAGA,QACA,oDACAH,EAAAA,EAAAA,EAAAA,MAAAA,MACAA,EAAAA,KAAAA,MAAAA,EAAAA,IAEAG,EAAAA,GAAAA,KAAAA,IACAH,EACAG,EAAAA,GAEA,CACA,CAKA,gBACA,WACA,UACA,oBACA,MACAxB,EAAAA,IAAAA,EACAb,EAAAA,KAAAA,IAAAA,EAAAA,EAAAA,IAGA,CAEA,OACAA,IAAAA,EACAc,OAAAA,EAEA,EAEAwB,YAAAA,CAAAA,EAAAA,EAAAA,EAAAA,GACA,0CAEA,eACA,IACAlB,EAAAA,KAAAA,MAGA,IACAmB,EAAAA,KAAAA,QAGA,IACAC,EAAAA,KAAAA,SAGA,QACA9B,QAAAA,KAAAA,2BACA+B,EAAAA,IAAAA,KAAAA,KAMA,SACA,IAEArB,EAAAA,YAAAA,GACA,qBACA,kBACA,cAIA,mBACAA,EAAAA,UAAAA,EACA,UACAA,EAAAA,SAAAA,EAAAA,EAAAA,EAAAA,GACAsB,EAAAA,CACA,CACAC,EAAAA,EAAAA,EACA,CAKA,cACA,mBACAvB,EAAAA,UAAAA,EACAA,EAAAA,SAAAA,EAAAA,EAAAA,EAAAA,GAEA,wCACA,GAEAwB,OAAAA,GAAAA,GClcmP,I,UFO/OC,GAAY,OACd,EACArD,EACAC,GACA,EACA,KACA,KACA,MAIF,EAAeoD,EAAiB,O,wDGlBhC,IAAIrD,EAAS,WAAa,IAAIsD,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,YAAY,cAAc,CAACF,EAAG,MAAM,CAACE,YAAY,kBAAkB,CAACF,EAAG,MAAM,CAACG,IAAI,YAAYD,YAAY,mBAAmBF,EAAG,MAAM,CAACE,YAAY,iBAAiB,CAACF,EAAG,MAAM,CAACG,IAAI,QAAQD,YAAY,oBAAoBF,EAAG,MAAM,CAACG,IAAI,WAAWD,YAAY,yBAAyBN,EAAIQ,GAAG,KAAKJ,EAAG,MAAM,CAACE,YAAY,mBAAmBG,MAAM,CAAC,yBAAyB,gBAAgB,EACpe9D,EAAkB,CAAC,WAAa,IAAIqD,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,YAAY,uBAAuB,CAACF,EAAG,MAAM,CAAC,EAAE,CAACA,EAAG,IAAI,CAACK,MAAM,CAAC,yBAAyB,YAAY,CAACL,EAAG,OAAO,CAACE,YAAY,4BAA4BF,EAAG,IAAI,CAACK,MAAM,CAAC,yBAAyB,YAAY,CAACL,EAAG,OAAO,CAACE,YAAY,eAAeG,MAAM,CAAC,yBAAyB,gBAAgBL,EAAG,OAAO,CAACE,YAAY,iBAAiBG,MAAM,CAAC,yBAAyB,aAAa,G,0LC2C7e,GACA7D,KAAAA,SACAC,OAAAA,CAAAA,EAAAA,EAAAA,EAAAA,GACA6D,MAAAA,CAAAA,MAAAA,eAAAA,aAAAA,YAAAA,wBAAAA,MAAAA,SACA5D,KAAAA,WACA,OACA6D,SAAAA,EACAC,YAAAA,EACAC,aAAAA,EACAC,oBAAAA,IACAC,KAAAA,UACAC,gBAAAA,CACA,aACA,gBACA,mBACA,wBACA,0BACA,gBACA,YACA,aACA,eAGA,EACA7D,WAAAA,CAAAA,EAEAC,QAAAA,CACA6D,UAAAA,GACA,mCACA,uBACA,8CACA,gBACA,mEACA,mEACA,WACA,EAEAC,IAAAA,GACA,aACA,wBACA,+EACA,iBACA,uBACA,wBACA,0BACA,iCACA,CACA,EAEAC,QAAAA,CAAAA,GACA,gBACA,EAEAC,eAAAA,CAAAA,GACA,mBACA,EAEAC,SAAAA,CAAAA,GACA,aACA,EAEAC,QAAAA,CAAAA,GACA,wCACA,uDACA,eACA,EAEAC,QAAAA,GACA,wCACA,EAEAC,UAAAA,CAAAA,EAAAA,GACA,2CACA,IAEA,iBACA,eACAC,EAAAA,OAAAA,QACA,oCASA,sCACA,qBACA,OACA,yBACAC,EAAAA,KAAAA,OAAAA,EAAAA,GACA,oGACAC,EAAAA,MAAAA,KAAAA,oBACAA,EAAAA,aAAAA,GAGA,CAKA,8BAMA,mCAGA,gEACA,kCAMA,iCAQA,cAKA,sBAMA,qBAKA,oBACA,eACA,UACA/D,QAAAA,MAAAA,EAAAA,KACAA,QAAAA,MAAAA,EAAAA,MACA,CAIA,EAKAgE,aAAAA,GACA,QACA,KACA,mBAGA,IADA,qBACA,mBAEA,IADA,WACA,sBACA,OACAC,OAAAA,EAAAA,OACAC,KAAAA,EAAAA,EAAAA,GACAtE,EAAAA,EAAAA,EAAAA,GACAC,EAAAA,EAAAA,EAAAA,GACAsE,IAAAA,EAAAA,QAEA,0CACAC,EAAAA,GAAAA,EACAC,EAAAA,KAAAA,IAAAA,EAAAA,KACA,CAGA,mBACA,CACA,oBACA,gDACA,EAMAC,cAAAA,GACA,4CAKA,cAMA,+BACA,kCACA,kCAMA,SACA,KACA,sBAKA,SACA,KACA,oBACA,QACA,sCACA,qBAIA,0CAKA,oDAEA,kCAMA,gBACA,WACA,0CACAC,EAAAA,GAAAA,EAEA,WACA,wCACAC,EAAAA,GAAAA,CACA,CAIAC,EAAAA,CACA,CAWA,wBAMA,qBAEA,wBACA,MAKA,UACA,oCACAC,EAAAA,GAAAA,EACAH,EAAAA,GAAAA,EAEA,uCACAI,EAAAA,GAAAA,EACAH,EAAAA,GAAAA,CACA,CAGA,kBAEA,eACA,aAGA,aACA,IACAI,EAAAA,KAAAA,oBAAAA,EAAAA,OAAAA,IAEA,eACA,IACAC,EAAAA,KAAAA,oBAAAA,EAAAA,OAAAA,IAIA,IACA,EACA,EAFA,KASA,IACA,uDACAC,EAAAA,GAQA,mCAKA,UAMA,QASA,GARA,eAEAnE,EADA,QACAA,EAAAA,KAAAA,EAAAA,EAAAA,MAAAA,EAAAA,UAEAA,KAAAA,IAAAA,EAAAA,EAAAA,EAAAA,YAIA,OAIAoE,EAAAA,EAAAA,uBAAAA,EAAAA,EAAAA,GACAA,EAAAA,KAAAA,KAAAA,iBACAA,EAAAA,MAAAA,EAQA,WACA,oBACA,UAEAA,EAAAA,GAAAA,EAAAA,IAGAR,EAAAA,GAAAA,EAAAA,EAAAA,MAAAA,GAGA,MAKAS,EAAAA,EAAAA,qBAAAA,EAAAA,EAAAA,GACAA,EAAAA,KAAAA,KAAAA,eACAA,EAAAA,MAAAA,GAEAA,EAAAA,IAEA,CAEA,OACAC,GAAAA,GAGA,0CACA,IACA,wCAEA,CACA,MACAjF,QAAAA,KAAAA,+BAAAA,EAEA,CACA,CAKA,SACA,sCACA,qBACA,qBACAL,EAAAA,KAAAA,EAEA,CACA,cAEA,iEACA,EAEAuF,mBAAAA,CAAAA,EAAAA,GACA,kCACA,MACA,OACAtF,EAAAA,KAAAA,MAAAA,EAAAA,EAAAA,EAAAA,GACAC,EAAAA,KAAAA,MAAAA,EAAAA,EAAAA,EAAAA,GACAsF,EAAAA,KAAAA,MAAAA,EAAAA,EAAAA,EAAAA,GACAC,EAAAA,KAAAA,MAAAA,EAAAA,EAAAA,EAAAA,IAEA,QACA,CACA,EAGAC,mBAAAA,CAAAA,EAAAA,GAQA,yBACAC,EAAAA,KAAAA,KAAAA,iBACAA,EAAAA,MAAAA,EAGA,kCACA,mCACAC,MAAAA,GAIA,QACA,EAEAC,sBAAAA,CAAAA,GACA,OACA5F,EAAAA,EACAC,EAAAA,EACAsF,EAAAA,EACAC,EAAAA,EACAK,OAAAA,GAEAC,EAAAA,KAAAA,KAAAA,eACAA,EAAAA,MAAAA,EAGA,kCACA,oCACA,sCAEA,wCAGA,QACA,EAKAC,yBAAAA,GACA,uDAOA,8BAEA,KAEA,KACA,KAEA,GACAC,KAAAA,SACAC,MAAAA,GAEA,KAIA,sCACA,qBACA,WAOA,mBAyCA,GAxCAC,EAAAA,EAAAA,IAAAA,EAAAA,GACAC,EAAAA,EAOA,kCAGA,MAMAC,EAAAA,GAAAA,EAAAA,QAAAA,EAAAA,MASA,kCACA,+CAGAhG,QAAAA,KAAAA,kDAAAA,IAUA,gCACAiG,EAAAA,EAAAA,IAAAA,EAAAA,MACAC,EAAAA,CACAN,KAAAA,SACAC,MAAAA,EAAAA,MAAAA,YAGA,sDAIA,OACAD,KAAAA,SACAC,MAAAA,GAEAI,EAAAA,EAAAA,IAAAA,EACAC,EAAAA,EAKA,wBACA,sFACA,oCACAC,EAAAA,MAAAA,EAAAA,UAOA,MAIAF,EAAAA,EAAAA,IAAAA,EAOA,GAJA,yBACAG,EAAAA,IAGA,yBACA,2BACA,KACAA,EAAAA,KAAAA,EAAAA,QAEA,CAEA,kCACA,gBACA,gCACA,KACAA,EAAAA,KAAAA,EAAAA,UAAAA,GAEA,MACApG,QAAAA,MAAAA,uDAAAA,GAIA,6BACA,2BACA,MACAoG,EAAAA,OAAAA,EAAAA,EAEA,CACAC,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,MAAAA,EACA,CAGA,qBACA,sBACA,qBAEA,qDACA,EAOAC,UAAAA,CAAAA,EAAAA,EAAAA,EAAAA,GACA,gBACA,WACA,yBACAC,EAAAA,MAAAA,EAEA,CACA,EAUAC,gBAAAA,GACA,8CAEA,cACAC,EAAAA,YAAAA,KAAAA,UACAA,EAAAA,SAAAA,KAAAA,OACAA,EAAAA,QAAAA,QACAA,EAAAA,eAAAA,EAAAA,GAEA,oCAEA,KACA,KAEA,iCACA,4BACA,0BACA,MACA,UACAC,EAAAA,EAAAA,IAAAA,CAAAA,GAEA,4BACA,MACA,mBACA,IAEAV,EAAAA,GAAAA,EACAU,EAAAA,EAAAA,IAAAA,GAAAA,EAEA,CACA,CAEA,CAEA,OADAD,EAAAA,UACA,CACA,EAEAE,UAAAA,GAGA,GADA,kBACA,mBAEA,2BACA9C,EAAAA,KAAAA,gBAAAA,GAGA,IADA,8BACA,mBACA,kCAEA,gDAGA,CAEA,WACA,EAEA+C,MAAAA,CAAAA,GACA,kBACA,mBACA,oBACA,eACA,EAEAC,MAAAA,CAAAA,GACA,kBAKA,kCACA,mBACA,qBAGA,aAGA,YAFA,YAIA,EAEApB,KAAAA,GACA,gBACAqB,EAAAA,EAAAA,IAAAA,KAAAA,SAAAA,aACAA,EAAAA,EAAAA,OAAAA,KAAAA,SAAAA,YACA,mCACAC,sBAAAA,EAAAA,EAAAA,MAAAA,KAAAA,QACA,EAIAC,IAAAA,GACA,gBACAF,EAAAA,EAAAA,OAAAA,KAAAA,SAAAA,aACAA,EAAAA,EAAAA,IAAAA,KAAAA,SAAAA,WACA,EAGAG,IAAAA,GACA,2BACA,kBACA,gBACA,oBAGA,gCACA,+BACA,cACAF,sBAAAA,EAAAA,EAAAA,MAAAA,KAAAA,WAIA,+BACA,YAGA,EAIAjI,MAAAA,GACA,oCAGA,4BAAAoI,UAAAA,IACA,wCACA,0CACA,kCAEA,oCAEA,2BACA,kCACA,2CACA,yCAEA,yEACA,uBACA,oBACA,EAEAC,aAAAA,GACA,kCACA,oCAGA,OAFAL,EAAAA,EAAAA,IAAAA,EAAAA,qBACA,eACA,CACA,EAEAM,aAAAA,GACA,qBACA,yCACA,6BACA,0BACA,WACA,MACA,6CACA,wCACA,sBACA,CACA,CACA,6BACAN,EAAAA,EAAAA,IAAAA,KAAAA,MAAAA,MAAAA,aAEA,CACA,EAEAO,UAAAA,CAAAA,EAAAA,EAAAA,GACA,gBACAC,IAAAA,0BACAA,IAAAA,qBAAAA,GACAC,MAAAA,KAAAA,MAAAA,OAEAC,EAAAA,MAAAA,KAAAA,KAAAA,IAAAA,GAAAA,IAAAA,GAAAA,IACAA,EAAAA,MAAAA,MAAAA,KAAAA,IAAAA,EAAAA,IAAAA,GAAAA,GACA,EAGAC,aAAAA,GACA,WAUA,OATA,kBACA,8BACA,SACAhC,MAAAA,EAAAA,UAAAA,KAAAA,IACAiC,OAAAA,GAEAvH,EAAAA,KAAAA,EAAAA,IAGA,CACA,EAEAwH,eAAAA,GAKA,SACA,sCACA,qBACAC,EAAAA,KAAAA,EACA,CACAA,EAAAA,MAAAA,SAAAA,EAAAA,GACA,oBACA,IAEA,4BACA,2BAKA,oCAEA,4BACA,WACA,SACA,MAEA,wCACA,oCACAd,EAAAA,EAAAA,IAAAA,EAAAA,mBACAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,MACA,sCACA,yFACA,6CAGAe,GAAAA,MAAAA,KAAAA,cAAAA,EAAAA,MAFAA,GAAAA,MAAAA,KAAAA,mBAAAA,EAAAA,OAIA,mCAEAA,GADA,EACAA,aAAAA,EAAAA,KAAAA,SAEAA,aAAAA,EAAAA,OAAAA,QAEA,wCACA,gBACA,+BAEAA,GADA,EACAA,aAAAA,KAAAA,gBAAAA,EAAAA,MAAAA,aAAAA,EAAAA,KAAAA,SAEAA,aAAAA,KAAAA,gBAAAA,EAAAA,MAAAA,YAAAA,EAAAA,OAAAA,QAEA,wCACA,gBACA,+BAEAA,GADA,EACAA,MAAAA,KAAAA,gBAAAA,EAAAA,MAAAA,aAAAA,EAAAA,KAAAA,SAEAA,MAAAA,KAAAA,gBAAAA,EAAAA,MAAAA,YAAAA,EAAAA,OAAAA,SAEA,mCAEAA,GADA,EACAA,aAAAA,EAAAA,KAAAA,SAEAA,aAAAA,EAAAA,OAAAA,QAEA,MACA,mCAEAA,GADA,EACAA,MAAAA,KAAAA,cAAAA,EAAAA,MAAAA,aAAAA,EAAAA,KAAAA,SAEAA,MAAAA,KAAAA,cAAAA,EAAAA,MAAAA,YAAAA,EAAAA,OAAAA,QAGA,CAEAC,EAAAA,UAAAA,KAAAA,UAAAA,GACAC,EAAAA,YAAAA,GACA,8DACA,MACA,CACA,oCACAjB,EAAAA,EAAAA,IAAAA,EAAAA,sCACA,qFACAgB,EAAAA,UAAAA,EACAC,EAAAA,YAAAA,GACA,+DAEA,qCACAjB,EAAAA,EAAAA,IAAAA,EAAAA,8CACAgB,EAAAA,YAAAA,GACA,gEACA,CAEA,CACA,6BACA,EAEAE,MAAAA,CAAAA,GACA,6BAEA,kBACA,0CAEAC,EAAAA,MAAAA,MAAAA,KAAAA,MAAAA,EAAAA,GAAAA,KACAA,EAAAA,MAAAA,OAAAA,EAAAA,EAAAA,KACAC,EAAAA,MAAAA,OAAAA,EAAAA,EAAAA,KACAA,EAAAA,YAAAA,GAEA,mCACA,iDAIA,cACA,wDACAC,EAAAA,GAAAA,EACAA,EAAAA,GAAAA,EACAC,YAAAA,KACA,wBACA,IAEA,EAEAC,OAAAA,CAAAA,GACA,iCACA,oBACA,+BACA,iCACA,EAIAC,cAAAA,CAAAA,GACA,mBACA,oBACA,+BACA,kBACA,EAKAC,OAAAA,CAAAA,EAAAA,GAKA,cAOA,0EACA,wBAMA,mCAGA,IAIA,WAEA,0BACA,yCAEA,8CAUA,gCACA,GACA,4BAEA,iEAEA,0CAEA,6DAMA,uDAQA,QACA,IACAC,EAAAA,KAAAA,IAAAA,EAAAA,KAAAA,KAAAA,IAAAA,IAEA,qBACA,4BAMA,+BACA,gBACA,WACA,6CACA,CAKA,oBAEA,yBAOA,gCACA,mCACA,qCACA,wCACA,MACAxI,QAAAA,KAAAA,+CAAAA,EAGA,UACAA,QAAAA,KAAAA,gCAAAA,EACA,CAGA,sBAEA,gBApGA,CAqGA,EAGAyI,cAAAA,CAAAA,EAAAA,GACA,gCAEA,yCACA,2CAIA,EAEAC,SAAAA,CAAAA,EAAAA,GAEA,+BACA,KACA,eACA,QACAC,EAAAA,UAAAA,KAAAA,iBAAAA,EAAAA,WAEA7I,GAAAA,KAAAA,IACA,yBACA,EACA,gCAEAE,QAAAA,MAAAA,yCAAAA,EAEA,MACA,qCAGAA,QAAAA,KAAAA,oCAAAA,EAAAA,GAIA,EAEA4I,oBAAAA,CAAAA,EAAAA,GACA,WACA,KAIA,4BACA,WACA,gBAGA,SAFAzI,EAAAA,CAIA,MAEAH,QAAAA,KAAAA,6CAEA,QACA,EAQA6I,QAAAA,CAAAA,GAEA,IADA,WACA,8CACA,qBACA,kBACA,OACA,MAEA9E,EAAAA,EACA,mBACA,CACA,QACA,EAGA+E,SAAAA,CAAAA,GACA,wBACA,mBACA,OAIA,OAHA,OACAC,EAAAA,IAAAA,GAEA,OACA,GAEA7G,OAAAA,GACA,GCnsC4Q,I,UCOxQC,GAAY,OACd,EACArD,EACAC,GACA,EACA,KACA,KACA,MAIF,EAAeoD,EAAiB,O","sources":["webpack://quant-ux/./src/dash/Heat.vue","webpack://quant-ux/src/dash/Heat.vue","webpack://quant-ux/./src/dash/Heat.vue?f898","webpack://quant-ux/./src/views/apps/test/VideoPlayer.vue?1bf9","webpack://quant-ux/src/views/apps/test/VideoPlayer.vue","webpack://quant-ux/./src/views/apps/test/VideoPlayer.vue?b15e","webpack://quant-ux/./src/views/apps/test/VideoPlayer.vue"],"sourcesContent":["var render, staticRenderFns\nimport script from \"./Heat.vue?vue&type=script&lang=js\"\nexport * from \"./Heat.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","\n<script>\nimport DojoWidget from \"dojo/DojoWidget\";\nimport _Color from \"common/_Color\";\n\nexport default {\n  name: \"Heat\",\n  mixins: [_Color, DojoWidget],\n  data: function () {\n    return {\n      defaultRadius: 15,\n      defaultBlur: 20,\n      defaultGradient: {\n        0.4: \"blue\",\n        0.6: \"cyan\",\n        0.7: \"lime\",\n        0.8: \"yellow\",\n        \"1.0\": \"red\",\n      },\n      max: -1,\n    };\n  },\n  components: {},\n  methods: {\n    computeMouseDistribution(events, model) {\n      var result = {};\n      /**\n       * Sort by screen\n       */\n      var screens = {};\n      for (let i = 0; i < events.length; i++) {\n        let event = events[i];\n        if (!screens[event.screen]) {\n          screens[event.screen] = [];\n        }\n        screens[event.screen].push(event);\n      }\n\n      /**\n       * 1) for each screen\n       */\n      for (let id in screens) {\n        var screenModel = model.screens[id];\n        if (screenModel) {\n          /**\n           * 2) Loop over all events and build one array\n           */\n          var screenEvents = screens[id];\n          var temp = [];\n          for (let i = 0; i < screenEvents.length; i++) {\n            /**\n             * 2.a) Loop over all mouse position in the event.\n             */\n            let event = screenEvents[i];\n            var xs = event.x;\n            var ys = event.y;\n            var ts = event.t;\n            for (let j = 0; j < xs.length; j++) {\n              temp.push({\n                x: xs[j],\n                y: ys[j],\n                t: ts[j],\n              });\n            }\n          }\n\n          /**\n           * 2.b) sort by time\n           */\n          temp.sort(function (a, b) {\n            return a.t - b.t;\n          });\n\n          /**\n           * 3)  build matrix\n           */\n          var width = screenModel.w;\n          var height = screenModel.h;\n\n          var lastT = 0;\n          var m = {};\n          var max = -1;\n\n          for (let i = 0; i < temp.length; i++) {\n            var e = temp[i];\n            var tDif = 0;\n\n            if (lastT > 0) {\n              tDif = Math.log(e.t - lastT);\n            }\n\n            if (lastT > e.t) {\n              console.error(\"wrong order\", i, e.t);\n            }\n\n            /**\n             * 4) Build matrix with tDif as intensity\n             */\n            if (e.x > 0 && e.y > 0) {\n              var x = Math.round(e.x * width);\n              var y = Math.round(e.y * height);\n\n              if (m[x] == null) {\n                m[x] = {};\n              }\n              if (m[x][y] == null) {\n                m[x][y] = 0;\n              }\n              m[x][y] += tDif;\n\n              max = Math.max(max, m[x][y]);\n            }\n\n            lastT = e.t;\n          }\n\n          result[id] = {\n            max: max,\n            values: this._matrixToData(m),\n          };\n        } else {\n          console.debug(\"No Screen Model for \", id);\n        }\n      }\n\n      return result;\n    },\n\n    /***********************************************************\n     *  Click\n     ***********************************************************/\n\n    computeClickDistribution(value, width, height) {\n      var m = {};\n      var max = -1;\n      for (var i = 0; i < value.length; i++) {\n        var e = value[i];\n\n        if (e.x && e.y && !e.noheat) {\n          var x = Math.round(e.x * width);\n          var y = Math.round(e.y * height);\n          if (x > 0 && y > 0) {\n            if (m[x] == null) {\n              m[x] = {};\n            }\n            if (m[x][y] == null) {\n              m[x][y] = 0;\n            }\n            m[x][y]++;\n\n            max = Math.max(max, m[x][y]);\n          }\n        }\n      }\n\n      return {\n        max: max,\n        values: this._matrixToData(m),\n      };\n    },\n\n    /**\n     * convert sparse matrix to dense matrix that is needed for rendering\n     */\n    _matrixToData(m) {\n      var data = [];\n      for (var x in m) {\n        var row = m[x];\n        for (var y in row) {\n          var pos = [];\n          pos[0] = x;\n          pos[1] = y;\n          pos[2] = m[x][y];\n          data.push(pos);\n        }\n      }\n      return data;\n    },\n\n    cleanUpHeat() {\n      delete this._circle;\n    },\n\n    /***************************************************************************************\n     * code inspired by https://github.com/mourner/simpleheat/blob/gh-pages/simpleheat.js\n     ***************************************************************************************/\n\n    draw: function (ctx, data, max, width, height, minOpacity) {\n\n      if (width <= 0 || height <= 0) {\n        return\n      }\n\n      if (!this._circle) {\n        this.radius(this.defaultRadius, this.defaultBlur);\n      }\n      if (!this._grad) {\n        this.gradient(this.defaultGradient);\n      }\n\n      ctx.clearRect(0, 0, width, height);\n\n      // draw a grayscale heatmap by putting a blurred circle at each data point\n      for (var i = 0, len = data.length, p; i < len; i++) {\n        p = data[i];\n        ctx.globalAlpha = Math.max(\n          p[2] / max,\n          minOpacity === undefined ? 0.05 : minOpacity\n        );\n        ctx.drawImage(this._circle, p[0] - this._r, p[1] - this._r);\n      }\n\n      // colorize the heatmap, using opacity value of each pixel to get the right color from our gradient\n      var colored = ctx.getImageData(0, 0, width, height);\n      this._colorize(colored.data, this._grad);\n      ctx.putImageData(colored, 0, 0);\n    },\n\n    radius: function (r, blur) {\n      blur = blur || 15;\n\n      // create a grayscale blurred circle image that we'll use for drawing points\n      var circle = (this._circle = document.createElement(\"canvas\"));\n      var ctx = circle.getContext(\"2d\");\n      var r2 = (this._r = r + blur);\n\n      circle.width = circle.height = r2 * 2;\n\n      ctx.shadowOffsetX = ctx.shadowOffsetY = 200;\n      ctx.shadowBlur = blur;\n      ctx.shadowColor = \"black\";\n\n      ctx.beginPath();\n      ctx.arc(r2 - 200, r2 - 200, r, 0, Math.PI * 2, true);\n      ctx.closePath();\n      ctx.fill();\n\n      return this;\n    },\n\n    gradient: function (grad) {\n      // create a 256x1 gradient that we'll use to turn a grayscale heatmap into a colored one\n      var canvas = document.createElement(\"canvas\");\n      var ctx = canvas.getContext(\"2d\");\n      var gradient = ctx.createLinearGradient(0, 0, 0, 256);\n\n      canvas.width = 1;\n      canvas.height = 256;\n\n      for (var i in grad) {\n        gradient.addColorStop(i * 1, grad[i]);\n      }\n\n      ctx.fillStyle = gradient;\n      ctx.fillRect(0, 0, 1, 256);\n\n      this._grad = ctx.getImageData(0, 0, 1, 256).data;\n\n      return this;\n    },\n\n    _colorize: function (pixels, gradient) {\n      for (var i = 3, len = pixels.length, j; i < len; i += 4) {\n        j = pixels[i] * 4; // get gradient color from opacity value\n\n        if (j) {\n          pixels[i - 3] = gradient[j];\n          pixels[i - 2] = gradient[j + 1];\n          pixels[i - 1] = gradient[j + 2];\n        }\n      }\n    },\n\n    /***********************************************************\n     *  Scroll Heat Map Stuff\n     ***********************************************************/\n\n    computeScrollDurationDistrubtion(value, visibleScreenSize, height) {\n      /**\n       * Init heatmap with 0s\n       */\n      var result = [];\n      for (let i = 0; i < height; i++) {\n        result[i] = 1;\n      }\n      var max = 1;\n\n      var lastEventTime = -1;\n      var lastScrollTop = -1;\n      for (let i = 0; i < value.length; i++) {\n        var e = value[i];\n\n        if (e.type == \"SessionStart\") {\n          lastEventTime = -1;\n          lastScrollTop = -1;\n        }\n\n        /**\n         * We are just interested in the ScreenLoaded and ScreenScroll events\n         */\n        if (e.type == \"ScreenScroll\" || e.type == \"ScreenLoaded\") {\n          var scrollTop = 0;\n          if (e.type == \"ScreenScroll\" && e.state && e.state.children) {\n            scrollTop = e.state.value * 1;\n            scrollTop = Math.floor(visibleScreenSize * scrollTop);\n          }\n\n          if (lastEventTime >= 0 && lastScrollTop >= 0) {\n            /**\n             * Now inc for the visible area with the duration\n             */\n            var duration = e.time - lastEventTime;\n\n            for (var j = 0; j < visibleScreenSize; j++) {\n              var r = lastScrollTop + j;\n              if (r < height) {\n                result[r] += duration;\n                max = Math.max(max, result[r]);\n              }\n            }\n          }\n          lastEventTime = e.time;\n          lastScrollTop = scrollTop;\n        }\n      }\n\n      return {\n        max: max,\n        values: result,\n      };\n    },\n\n    computeScrollVisibiltyDistribution(value, visibleScreenSize, height) {\n      /**\n       * Init heatmap with 0s\n       */\n      var result = [];\n      for (let i = 0; i < height; i++) {\n        result[i] = 1;\n      }\n      let max = 1;\n\n      /**\n       * Loop over all events. Just just ScreenLoaded and Scroll events\n       * to update the heapmap.\n       *\n       * We do this by user the concept of a ScreenSession. A ScreenSession includes all events,\n       * from one ScreenLoaded event until the next ScreenLoaded event. We store for each ScreenSession\n       * the max scrollTop value for all events in the session\n       */\n      var lastPageLoad = null;\n      var pageSessions = {};\n      for (let i = 0; i < value.length; i++) {\n        var e = value[i];\n        /**\n         * We are just interested in the ScreenLoaded and ScreenScroll events\n         */\n        if (e.type == \"ScreenScroll\" || e.type == \"ScreenLoaded\") {\n          if (e.type == \"ScreenLoaded\") {\n            lastPageLoad = e.id;\n            if (!pageSessions[lastPageLoad]) {\n              pageSessions[lastPageLoad] = 0;\n            }\n          }\n          var scrollTop = 0;\n          if (e.type == \"ScreenScroll\" && e.state && e.state.children) {\n            scrollTop = e.state.value * 1;\n            scrollTop = Math.floor(visibleScreenSize * scrollTop);\n          }\n          pageSessions[lastPageLoad] = Math.max(\n            scrollTop,\n            pageSessions[lastPageLoad]\n          );\n        }\n      }\n\n      /**\n       * Now we build the final gradient\n       */\n      for (var id in pageSessions) {\n        let scrollTop = pageSessions[id];\n        let to = visibleScreenSize * 1 + scrollTop * 1;\n        for (var j = 0; j < to; j++) {\n          if (j < height) {\n            result[j] += 1;\n            max = Math.max(max, result[j]);\n          }\n        }\n      }\n\n      return {\n        max: max,\n        values: result,\n      };\n    },\n\n    drawSections(dist, ctx, height, width) {\n      this.logger.log(2, \"drawSections\", \"enter\");\n\n      var result = dist.values;\n      if (!ctx) {\n        ctx = this._ctx;\n      }\n\n      if (!width) {\n        width = this._width;\n      }\n\n      if (!height) {\n        height = this._height;\n      }\n\n      if (!dist.max) {\n        console.warn(\"drawSections() > no max\");\n        dist.max = this.max;\n      }\n\n      /**\n       * Now turn to relative values\n       */\n      var lastValue = -1;\n      var lastY = 0;\n\n      ctx.globalAlpha = 0.4;\n      for (let i = 0; i < height; i++) {\n        if (lastValue != result[i] && lastValue >= 0) {\n          let value = lastValue / dist.max;\n          /**\n           * FIXME: get color from gradient!!\n           */\n          let color = this.mixColor(value);\n          ctx.fillStyle = color;\n          var h = i - lastY;\n          ctx.fillRect(0, lastY, width, h);\n          lastY = i;\n        }\n        lastValue = result[i];\n      }\n\n      /**\n       * last section?\n       */\n      var value = lastValue / dist.max;\n      var color = this.mixColor(value);\n      ctx.fillStyle = color;\n      ctx.fillRect(0, lastY, width, height);\n\n      this.logger.log(2, \"drawSections\", \"exit\");\n    },\n  },\n  mounted() {},\n};\n</script>","import mod from \"-!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Heat.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Heat.vue?vue&type=script&lang=js\"","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"MatcPlayer\"},[_c('div',{staticClass:\"MatcPlayerLeft\"},[_c('div',{ref:\"container\",staticClass:\"MatcPlayerView\"}),_c('div',{staticClass:\"MatcPlayerNav\"},[_c('div',{ref:\"tasks\",staticClass:\"MatcPlayerTasks\"}),_c('div',{ref:\"progress\",staticClass:\"MatcPlayerProgress\"})]),_vm._m(0)]),_c('div',{staticClass:\"MatcPlayerEvents\",attrs:{\"data-dojo-attach-point\":\"eventCntr\"}})])}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"MatcPlayerButtonBar\"},[_c('div',{},[_c('a',{attrs:{\"data-dojo-attach-point\":\"btnBack\"}},[_c('span',{staticClass:\"mdi mdi-skip-previous\"})]),_c('a',{attrs:{\"data-dojo-attach-point\":\"btnPlay\"}},[_c('span',{staticClass:\"mdi mdi-play\",attrs:{\"data-dojo-attach-point\":\"iconPlay\"}})]),_c('span',{staticClass:\"MatcPlayerTime\",attrs:{\"data-dojo-attach-point\":\"time\"}})])])}]\n\nexport { render, staticRenderFns }","<template>\n     <div class=\"MatcPlayer\">\n\t\t<div class=\"MatcPlayerLeft\">\n\t\t\t<div class=\"MatcPlayerView\" ref=\"container\">\n\t\t\t</div>\n\t\t\t<div class=\"MatcPlayerNav\">\n\t\t\t\t<div class=\"MatcPlayerTasks\" ref=\"tasks\">\n\t\t\t\t</div>\n\t\t\t\t<div class=\"MatcPlayerProgress\" ref=\"progress\">\n\t\t\t\t</div>\n\t\t\t</div>\t\n\t\t\n\t\t\t<div class=\"MatcPlayerButtonBar\">\n\t\t\t\t<div class=\"\">\n\t\t\t\t\t<a data-dojo-attach-point=\"btnBack\"><span class=\"mdi mdi-skip-previous\"></span></a>\n\t\t\t\t\t<a data-dojo-attach-point=\"btnPlay\"><span data-dojo-attach-point=\"iconPlay\" class=\"mdi mdi-play\"></span></a>\n\t\t\t\t\t<span class=\"MatcPlayerTime\" data-dojo-attach-point=\"time\"></span>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"MatcPlayerEvents\" data-dojo-attach-point=\"eventCntr\">\n\n\t\t</div>\n\t</div>\n</template>\n<script>\nimport DojoWidget from 'dojo/DojoWidget'\nimport css from 'dojo/css'\nimport on from 'dojo/on'\nimport touch from 'dojo/touch'\nimport lang from 'dojo/_base/lang'\nimport domGeom from 'dojo/domGeom'\nimport Logger from 'common/Logger'\nimport DataFrame from 'common/DataFrame'\nimport HSlider from 'common/HSlider'\nimport DomBuilder from 'common/DomBuilder'\nimport Util from 'core/Util'\nimport RenderFactory from 'core/RenderFactory'\nimport Animation from 'core/Animation'\nimport Analytics from 'dash/Analytics'\nimport Preview from 'page/Preview'\nimport Core from 'core/Core'\nimport Services from 'services/Services'\n\nexport default {\n    name: 'Player',\n\tmixins:[DojoWidget, Util],\n\tprops: [\"app\", \"testSettings\", \"annotation\", \"sessionID\", \"eventsWithAnnimations\", \"pub\", \"mouse\"],\n    data: function () {\n        return {\n            running: false,\n            currentTime: 0,\n            lastEventPos: 0,\n            animationTimeOffSet: 400,\n            mode: \"private\",\n            invisibleEvents: {\n\t\t\t\t\"Animation\": true,\n\t\t\t\t\"SessionStart\": true,\n\t\t\t\t\"ScreenAnimation\": true,\n\t\t\t\t\"OverlayShowAnimation\": true,\n\t\t\t\t\"OverlayRemoveAnimation\": true,\n\t\t\t\t\"ValidationOk\": true,\n\t\t\t\t\"MouseOut\": true,\n\t\t\t\t\"MouseOver\": true,\n\t\t\t\t\"WidgetInit\": true\n\t\t\t}\n        }\n    },\n\tcomponents: {},\n\n    methods: {\n      postCreate (){\n\t\t\tthis.logger = new Logger('VideoPlayer');\n\t\t\tthis.analytics = new Analytics();\n\t\t\tthis.jwtToken = Services.getUserService().getToken()\n\t\t\tthis.db = new DomBuilder()\n\t\t\tthis.own(on(this.btnBack, touch.press, lang.hitch(this, \"onBack\")));\n\t\t\tthis.own(on(this.btnPlay, touch.press, lang.hitch(this, \"onPlay\")));\n\t\t\tthis.init()\n\t\t},\n\n\t\tinit () {\n\t\t\tif (this.app) {\n\t\t\t\tthis.setModel(this.app)\n\t\t\t\tlet events = this.analytics.nornalizeContainerChildEvents(this.eventsWithAnnimations)\n\t\t\t\tvar df = new DataFrame(events);\n\t\t\t\tvar sessionGroup = df.groupBy(\"session\");\n\t\t\t\tvar session = sessionGroup.get(this.sessionID);\n\t\t\t\tthis.mouseData = this.mouse\n\t\t\t\tthis.setSession(session, this.sessionID)\n\t\t\t}\n\t\t},\n\n\t\tsetMouse (m) {\n\t\t\tthis.mouseData = m\n\t\t},\n\n\t\tsetTestSettings (t) {\n\t\t\tthis.testSettings = t\n\t\t},\n\n\t\tsetDialog(dialog) {\n\t\t\tthis.dialog = dialog\n\t\t},\n\n\t\tsetModel(model){\n\t\t\tthis.model = this.createInheritedModel(model);\n\t\t\tthis.model = Core.addContainerChildrenToModel(this.model)\n\t\t\tthis.initSize()\n\t\t},\n\n\t\tinitSize () {\n\t\t\tthis.previewWrapper = this.renderPreview()\n\t\t},\n\n\t\tsetSession(session,sessionID){\n\t\t\tthis.logger.log(0, \"setSession\", \"enter \" + sessionID);\n\t\t\ttry {\n\n\t\t\t\tthis.sessionID = sessionID;\n\t\t\t\tthis.session = session;\n\t\t\t\tsession.sortBy(\"time\");\n\t\t\t\tthis.events = lang.clone(session.as_array());\n\n\n\t\t\t\t/**\n\t\t\t\t * Now we have to the WidgetClick events a little and move them forward\n\t\t\t\t * if the trigger a screen transition, because otherwise the the animation\n\t\t\t\t * is deleted.\n\t\t\t\t * Also we fix ScreenGestures\n\t\t\t\t */\n\t\t\t\tfor(var i=0; i <this.events.length;i++){\n\t\t\t\t\tvar event = this.events[i];\n\t\t\t\t\tvar nextEvent = null;\n\t\t\t\t\tif(i +1 < this.events.length){\n\t\t\t\t\t\tnextEvent = this.events[i+1];\n\t\t\t\t\t\tif((nextEvent.type == \"ScreenLoaded\" || nextEvent.type == \"ScreenAnimation\") && ( event.type==\"WidgetClick\" || event.type == \"ScreenGesture\")){\n\t\t\t\t\t\t\tevent.time -= this.animationTimeOffSet;\n\t\t\t\t\t\t\tevent._transition = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Fix gestures\n\t\t\t\t */\n\t\t\t\tthis.fixGestures(this.events);\n\n\n\t\t\t\t/**\n\t\t\t\t * no check for tasks\n\t\t\t\t */\n\t\t\t\tthis.taskMatches = this.getMatches();\n\n\n\t\t\t\tthis.duration = this.session.max(\"time\") - this.session.min(\"time\");\n\t\t\t\tthis.min = this.session.min(\"time\");\n\n\n\t\t\t\t/**\n\t\t\t\t * init widget states\n\t\t\t\t */\n\t\t\t\t this.initWidgetStatesAndScroll();\n\n\n\t\t\t\t /**\n\t\t\t\t  * now build for all ui widgets a time series\n\t\t\t\t  * with the states. for every event we have to know the\n\t\t\t\t  * state of all widgets.\n\t\t\t\t  */\n\t\t\t \t this.render();\n\n\t\t\t\t /**\n\t\t\t\t  * init animations\n\t\t\t\t  */\n\t\t\t\t this.initAnimations();\n\n\n\t\t\t\t /**\n\t\t\t\t  *\n\t\t\t\t  */\n\t\t\t\t this.initMouseData();\n\n\t\t\t\t /**\n\t\t\t\t  * Start ship up\n\t\t\t\t  */\n\t\t\t\t this.lastEventPos =0;\n\t\t\t\t this.setTime(0);\n\t\t\t} catch(e){\n\t\t\t\tconsole.debug(e.err);\n\t\t\t\tconsole.debug(e.stack);\n\t\t\t}\n\n\t\t\t//console.debug(this._widgetAnimationStates)\n\n\t\t},\n\n\t\t/**\n\t\t * Transform raw array based mouse data into time based lookup table\n\t\t */\n\t\tinitMouseData(){\n\t\t\tvar maxMouse = 0;\n\t\t\tvar mouseStates = {};\n\t\t\tif(this.mouseData){\n\n\t\t\t\tvar d = this.mouseData;\n\t\t\t\tfor(var i=0; i< d.length; i++){\n\t\t\t\t\tvar batch = d[i];\n\t\t\t\t\tfor(var j=0; j < batch.t.length; j++){\n\t\t\t\t\t\tvar e = {\n\t\t\t\t\t\t\tscreen : batch.screen,\n\t\t\t\t\t\t\ttime : batch.t[j],\n\t\t\t\t\t\t\tx : batch.x[j],\n\t\t\t\t\t\t\ty : batch.y[j],\n\t\t\t\t\t\t\tdur : batch.sample\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar t  = this.getAnimationIndex(e.time-this.min);\n\t\t\t\t\t\tmouseStates[t] = e;\n\t\t\t\t\t\tmaxMouse = Math.max(e.time)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// delete this.mouseData\n\t\t\t\tthis.mouseData = null\n\t\t\t}\n\t\t\tthis._mouseStates = mouseStates;\n\t\t\tthis.duration = Math.max( maxMouse-this.min, this.duration);\n\t\t},\n\n\n\t\t/**\n\t\t * This method will loop over all events and will calculate the state for all widgets\n\t\t */\n\t\tinitAnimations(){\n\t\t\tthis.logger.log(0, \"initAnimations\", \"enter\");\n\n\t\t\t/**\n\t\t\t * we init this for all\n\t\t\t */\n\t\t\tvar aFac = new Animation();\n\n\t\t\t/**\n\t\t\t * Init lookup table... for every possible timestamp we\n\t\t\t * have a slot. In each slot we have info for each widget\n\t\t\t */\n\t\t\tthis._widgetAnimationStates = {};\n\t\t\tfor(let i=0; i< this.duration;  i+=30){\n\t\t\t\tthis._widgetAnimationStates[i] = {}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Init style holders\n\t\t\t */\n\t\t\tvar widgetInited = {};\n\t\t\tvar lastState = {};\n\t\t\tthis.styleIDCounter =0;\n\n\t\t\t/**\n\t\t\t * Init pos holders\n\t\t\t */\n\t\t\tvar lastPos = {};\n\t\t\tvar widgetInitedPos = {};\n\t\t\tthis.posIDCounter =0;\n\t\t\tvar lastScreenLoadTimeStamp = 0;\n\t\t\tfor(let i=0; i <this.events.length;i++){\n\t\t\t\tlet event = this.events[i];\n\t\t\t\t// let screenID = event.screen;\n\t\t\t\t// let widgetID = event.widget;\n\t\t\t\t// let widget = this.model.widgets[widgetID];\n\t\t\t\tlet start  = this.getAnimationIndex(event.time-this.min);\n\n\t\t\t\t/**\n\t\t\t\t * Reset style because of screen load\n\t\t\t\t */\n\t\t\t\tif(( event.type ==\"ScreenLoaded\" || event.type ==\"OverlayLoaded\")){\n\n\t\t\t\t\tfor(let j=start; j < this.duration; j+=30 ){\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Reset styles and pos\n\t\t\t\t\t\t */\n\t\t\t\t\t\t// let widgets = this._widgetAnimationStates[j];\n\t\t\t\t\t\tfor(let id in widgetInited){\n\t\t\t\t\t\t\tvar orgStyle = widgetInited[id];\n\t\t\t\t\t\t\tthis._widgetAnimationStates[j][id].style = orgStyle;\n\t\t\t\t\t\t\tlastState[animWidgetId] = orgStyle;\n\n\t\t\t\t\t\t\tvar orgPos = widgetInitedPos[id];\n\t\t\t\t\t\t\tthis._widgetAnimationStates[j][id].pos = orgPos;\n\t\t\t\t\t\t\tlastPos[animWidgetId] = orgPos;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t}\n\t\t\t\t\tlastScreenLoadTimeStamp = start;\n\t\t\t\t}\n\n\n\t\t\t\t/**\n\t\t\t\t * FIXME: Add here some Screen and Animation index! Otherwise Clicks or\n\t\t\t\t * Animations might stop the ScreenAnimation!\n\t\t\t\t */\n\t\t\t\t//if(event.type == \"ScreenAnimation\" ){\n\t\t\t\t//}\n\n\n\t\t\t\tif(event.type ==\"Animation\"){\n\t\t\t\t\t/**\n\t\t\t\t\t * The animation might have been triggered by the widgetID,\n\t\t\t\t\t * but it animated another widget, which is stored\n\t\t\t\t\t * in the event.animation.id\n\t\t\t\t\t */\n\t\t\t\t\tvar animWidgetId = event.animation.id;\n\n\t\t\t\t\tvar animWidget = this.model.widgets[animWidgetId];\n\t\t\t\t\tif(animWidget){\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * init the index with the original style as default. This should just be\n\t\t\t\t\t\t * a reference, therefore I hope it does not consume too much memory...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif(!widgetInited[animWidgetId]){\n\t\t\t\t\t\t\tlet orginalStyle = this.initWidgetAnimation(animWidgetId, animWidget);\n\t\t\t\t\t\t\twidgetInited[animWidgetId] = orginalStyle;\n\t\t\t\t\t\t\tlastState[animWidgetId] = orginalStyle;\n\n\t\t\t\t\t\t\tlet orgPos = this.initWidgetAnimationPos(animWidgetId, animWidget);\n\t\t\t\t\t\t\twidgetInitedPos[animWidgetId] = orgPos;\n\t\t\t\t\t\t\tlastPos[animWidgetId] = orgPos;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tvar animation = event.animation;\n\n\t\t\t\t\t\tvar fromStyle = animation.from.style;\n\t\t\t\t\t\tvar toStyle = animation.to.style;\n\n\n\t\t\t\t\t\tvar fromPos = animation.from.pos;\n\t\t\t\t\t\tif(fromPos){\n\t\t\t\t\t\t\tfromPos = this.getAbsolutePosition(event.screen, fromPos);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar toPos = animation.to.pos;\n\t\t\t\t\t\tif(toPos){\n\t\t\t\t\t\t\ttoPos = this.getAbsolutePosition(event.screen, toPos);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//console.debug(\"Animate \", start ,\"/\", this.duration , \" => \", animation.duration + start);\n\n\t\t\t\t\t\tvar animationEnded = false;\n\t\t\t\t\t\tvar mixed;\n\t\t\t\t\t\tvar mixedPos;\n\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * We have here a problem. The animations are started not with the correct\n\t\t\t\t\t\t * timestamp of we have onload animations!\n\t\t\t\t\t\t */\n\t\t\t\t\t\tvar startTimeStamp = start;\n\t\t\t\t\t\tif(event.animation && event.animation.triggerType ==\"ScreenLoaded\"){\n\t\t\t\t\t\t\tstartTimeStamp = lastScreenLoadTimeStamp;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Now calculate the state from the *start* point on.\n\t\t\t\t\t\t * j is the rolling timestamp\n\t\t\t\t\t\t */\n\t\t\t\t\t\tfor(let j=startTimeStamp; j < this.duration; j+=30 ){\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * The current time index for the animation. We substract start,\n\t\t\t\t\t\t\t * to make it start at 0\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tlet t = j - start;\n\n\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * Get the p\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tvar p = 1;\n\t\t\t\t\t\t\tif(animation.duration > 0){\n\t\t\t\t\t\t\t\tif(animation.delay){\n\t\t\t\t\t\t\t\t\tp = aFac.getP(t,animation.delay, animation.duration );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tp = Math.min(1, t / animation.duration);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(!animationEnded || !mixed){\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * Here we call the factory to get the animated style\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tmixed  =  aFac.getAnimationMixedStyle(fromStyle,toStyle, p );\n\t\t\t\t\t\t\t\tmixed._aid = this.styleIDCounter++;\n\t\t\t\t\t\t\t\tmixed._org = false;\n\n\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * now mix with last state to have full state at every\n\t\t\t\t\t\t\t\t * point of time. The last state must be correctly initialized\n\t\t\t\t\t\t\t\t * with the org style!\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvar last = lastState[animWidgetId];\n\t\t\t\t\t\t\t\tfor(var key in last){\n\t\t\t\t\t\t\t\t\tif(mixed[key] == undefined){\n\t\t\t\t\t\t\t\t\t\t//console.debug(\"-\", j , \"fill : \", key, mixed[key], \" <- \", last[key])\n\t\t\t\t\t\t\t\t\t\tmixed[key] = last[key];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlastState[animWidgetId] = lang.clone(mixed);\n\n\n\t\t\t\t\t\t\t\tif(fromPos && toPos){\n\n\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t * Do calculate here the mixedPos\n\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\tmixedPos = aFac.getAnimationMixedPos(fromPos,toPos, p );\n\t\t\t\t\t\t\t\t\tmixedPos._aid = this.posIDCounter++;\n\t\t\t\t\t\t\t\t\tmixedPos._org = false;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmixedPos = null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(p >=1){\n\t\t\t\t\t\t\t\tanimationEnded = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._widgetAnimationStates[j][animWidgetId].style = mixed;\n\t\t\t\t\t\t\tif(mixedPos){\n\t\t\t\t\t\t\t\tthis._widgetAnimationStates[j][animWidgetId].pos = mixedPos;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn(\"initAnimations() > No widgte\", animWidgetId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * HACK: we remove now all animation so ScreenAnaimtions run through\n\t\t\t */\n\t\t\tvar temp = [];\n\t\t\tfor(let i=0; i <this.events.length;i++){\n\t\t\t\tlet event = this.events[i];\n\t\t\t\tif(event.type !=\"Animation\"){\n\t\t\t\t\ttemp.push(event)\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.events = temp;\n\n\t\t\tthis.logger.log(0, \"initAnimations\", \"exit > \" + this.styleIDCounter);\n\t\t},\n\n\t\tgetAbsolutePosition(screenID, pos){\n\t\t\tvar screen = this.scaledModel.screens[screenID];\n\t\t\tif(screen){\n\t\t\t\tvar result = {\n\t\t\t\t\tx : Math.round(screen.w * pos.x),\n\t\t\t\t\ty : Math.round(screen.h * pos.y),\n\t\t\t\t\tw : Math.round(screen.w * pos.w),\n\t\t\t\t\th : Math.round(screen.h * pos.h)\n\t\t\t\t};\n\t\t\t\treturn result;\n\t\t\t}\n\t\t},\n\n\n\t\tinitWidgetAnimation(widgetID,widget ){\n\n\n\t\t\t/**\n\t\t\t * create here a copy and set and \"_aid\" id field\n\t\t\t * so we can later do the change checking faster\n\t\t\t * (oldstyle._aid == newstyle._aid).\n\t\t\t */\n\t\t\tvar orginalStyle = lang.clone(widget.style);\n\t\t\torginalStyle._aid = this.styleIDCounter++;\n\t\t\torginalStyle._org = true;\n\n\n\t\t\tfor(var j=0; j< this.duration;  j+=30){\n\t\t\t\tthis._widgetAnimationStates[j][widgetID] = {\n\t\t\t\t\tstyle :  orginalStyle\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn orginalStyle;\n\t\t},\n\n\t\tinitWidgetAnimationPos(widgetID){\n\t\t\tvar originalPos = {\n\t\t\t\tx :0,\n\t\t\t\ty: 0,\n\t\t\t\tw: 0,\n\t\t\t\th: 0,\n\t\t\t\tstart:true\n\t\t\t};\n\t\t\toriginalPos._aid = this.posIDCounter++;\n\t\t\toriginalPos._org = true;\n\n\n\t\t\tfor(var j=0; j< this.duration;  j+=30){\n\t\t\t\tif(!this._widgetAnimationStates[j][widgetID]){\n\t\t\t\t\tthis._widgetAnimationStates[j][widgetID] = {};\n\t\t\t\t}\n\t\t\t\tthis._widgetAnimationStates[j][widgetID].pos = originalPos;\n\t\t\t}\n\n\t\t\treturn originalPos;\n\t\t},\n\n\t\t/**\n\t\t * This method will loop over all events and will calculate the state for all widgets\n\t\t */\n\t\tinitWidgetStatesAndScroll(){\n\t\t\tthis.logger.log(1, \"initWidgetStatesAndScroll\", \"enter\");\n\n\t\t\t/**\n\t\t\t * we initialize with the default state of the widgets. We have an\n\t\t\t * states[screenID][widgetID][state] object. We do this because of the\n\t\t\t * radio buttons that we have to controll on a screen level...\n\t\t\t */\n\t\t\tvar lastStates = this.getDefaultStates();\n\n\t\t\tvar widgetStatesByEvent ={};\n\n\t\t\tvar overLays = [];\n\t\t\tvar overlayStatesByEvent ={};\n\n\t\t\tvar lastScroll = {\n\t\t\t\ttype:\"scroll\",\n\t\t\t\tvalue:0\n\t\t\t};\n\t\t\tvar screenScoll = {};\n\n\n\n\t\t\tfor(let i=0; i <this.events.length;i++){\n\t\t\t\tlet event = this.events[i];\n\t\t\t\tlet screenID = event.screen;\n\t\t\t\t// let eventID = event.id\n\n\t\t\t\t/**\n\t\t\t\t * 1) we clone that last state of all widgets. Then we set the state\n\t\t\t\t * for the current event to the states of the current screen!\n\t\t\t\t */\n\t\t\t\tvar states = lang.clone(lastStates)\n\t\t\t\twidgetStatesByEvent[event.id] = states[screenID];\n\t\t\t\tlastStates = states;\n\n\n\t\t\t\t/**\n\t\t\t\t * 2) if there is a new state, we update it\n\t\t\t\t * for the new state for the widget that emited it\n\t\t\t\t */\n\t\t\t\tif(event.state && event.type!=\"ScreenScroll\"){\n\n\n\t\t\t\t\tif(states[screenID]){\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * FIXME: If we do master-state-propagation, we have to update the state here, or?\n\t\t\t\t\t\t */\n\n\t\t\t\t\t\tstates[screenID][event.widget] = event.state;\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * FIXME: For the radio box we have to change  the\n\t\t\t\t\t\t * states of the other radio boxes. For now this hack is\n\t\t\t\t\t\t * ok, as I think we will only have one type of widgets with synced\n\t\t\t\t\t\t * states. Also if we have several radio button groups we have to fix\n\t\t\t\t\t\t * this...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif(event.state.type == \"radiobox.checked\"){\n\t\t\t\t\t\t\tthis._setStates(states[screenID],\"radiobox.checked\", false, event);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn(\"getWidgetStatesByEvent() > No state for screen \", screenID);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * 3) Here we build for each event the scrollPosition.\n\t\t\t\t * ScreenLoaded and ScreenAnimation will set the scrolling to 0!\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tif(event.type==\"ScreenScroll\" && event.state){\n\t\t\t\t\tscreenScoll[event.id] =event.state;\n\t\t\t\t\tlastScroll = {\n\t\t\t\t\t\ttype:\"scroll\",\n\t\t\t\t\t\tvalue:event.state.value\n\t\t\t\t\t};\n\n\t\t\t\t} else if(event.type==\"ScreenLoaded\" || event.type==\"ScreenAnimation\"){\n\t\t\t\t\t/**\n\t\t\t\t\t * We set scroll to 0. Simulator does the same\n\t\t\t\t\t */\n\t\t\t\t\tvar state = {\n\t\t\t\t\t\ttype:\"scroll\",\n\t\t\t\t\t\tvalue:0\n\t\t\t\t\t};\n\t\t\t\t\tscreenScoll[event.id] =state;\n\t\t\t\t\tlastScroll = state;\n\t\t\t\t\t/**\n\t\t\t\t\t * Add here scroll state only of we do not have a ScreenAnimation.\n\t\t\t\t\t * If a ScreenLoad follows a ScreenAnimation we do not reset as well!\n\t\t\t\t\t */\n\t\t\t\t\tvar lastEvent = this.events[i-1];\n\t\t\t\t\tif (lastEvent && event.type !=\"ScreenAnimation\" && !(lastEvent.type == \"ScreenAnimation\" && event.type == \"ScreenLoaded\")) {\n\t\t\t\t\t\tif(event.scrollTop != undefined && event.scrollTop != null){\n\t\t\t\t\t\t\tstate.value = event.scrollTop;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/**\n\t\t\t\t\t * FIXME: reset here all widget states??\n\t\t\t\t\t */\n\t\t\t\t} else {\n\t\t\t\t\t/**\n\t\t\t\t\t * other events took place at the same scroll position as before\n\t\t\t\t\t */\n\t\t\t\t\tscreenScoll[event.id] = lastScroll;\n\t\t\t\t}\n\n\t\t\t\tif(event.type==\"ScreenLoaded\" ){\n\t\t\t\t\toverLays = [];\n\t\t\t\t}\n\n\t\t\t\tif(event.type==\"OverlayLoaded\"){\n\t\t\t\t\tlet index = overLays.indexOf(event.overlay);\n\t\t\t\t\tif(index <0){\n\t\t\t\t\t\toverLays.push(event.overlay);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(event.type == \"OverlayShowAnimation\"){\n\t\t\t\t\tif(event.animation){\n\t\t\t\t\t\tlet index = overLays.indexOf(event.animation.to);\n\t\t\t\t\t\tif(index <0){\n\t\t\t\t\t\t\toverLays.push(event.animation.to);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.debug(\"initWidgetStatesAndScroll() > no animation for event\", event)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(event.type==\"OverlayRemoved\"){\n\t\t\t\t\tlet index = overLays.indexOf(event.overlay);\n\t\t\t\t\tif(index >-1){\n\t\t\t\t\t\toverLays.splice(index,1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toverlayStatesByEvent[event.id] = lang.clone(overLays);\n\t\t\t}\n\n\n\t\t\tthis._widgetStates = widgetStatesByEvent;\n\t\t\tthis._overLayStates = overlayStatesByEvent;\n\t\t\tthis._scrollStates = screenScoll;\n\n\t\t\tthis.logger.log(2, \"initWidgetStatesAndScroll\", \"exit\");\n\t\t},\n\n\n\n\n\n\n\t\t_setStates(states,type, value, event){\n\t\t\tfor(var id in states){\n\t\t\t\tvar s = states[id];\n\t\t\t\tif(s.type == type && id!= event.widget){\n\t\t\t\t\ts.value = value;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\n\n\n\t\t/**\n\t\t * This method gets the default state for every widget. It does this by renderibg each widget once, and calling the getState() method,\n\t\t * whoich should be corretly initialized form the UIWidget objects during rendering!\n\t\t */\n\t\tgetDefaultStates(){\n\t\t\tthis.logger.log(2, \"getDefaultStates\", \"enter\");\n\n\t\t\tvar fac = new RenderFactory();\n\t\t\tfac.setJwtToken(this.jwtToken)\n\t\t\tfac.setModel(this.model); // FIXME: Shouldn't this be zoomed?\n\t\t\tfac.setMode(\"view\");\n\t\t\tfac.setScaleFactor(1,1);\n\n\t\t\tvar dummy = document.createElement(\"div\");\n\n\t\t\tvar states = {};\n\t\t\tvar screenStates = {};\n\n\t\t\tfor(var id in this.model.widgets){\n\t\t\t\tvar widget = this.model.widgets[id];\n\t\t\t\tvar screen = this.getParentScreen(widget);\n\t\t\t\tif(screen){\n\t\t\t\t\tif(!screenStates[screen.id]){\n\t\t\t\t\t\tscreenStates[screen.id] = {};\n\t\t\t\t\t}\n\t\t\t\t\tvar uiWidget = fac.createUIWidget(dummy,  widget);\n\t\t\t\t\tif(uiWidget){\n\t\t\t\t\t\tvar state = uiWidget.getState();\n\t\t\t\t\t\tif(state){\n\t\t\t\t\t\t\t//this.logger.log(3, \"getDefaultStates\", \"State for widget '\" +id +\"' (\" + widget.name +  \") >> \" + state.type + \" :  \"+ state.value);\n\t\t\t\t\t\t\tstates[id] = state;\n\t\t\t\t\t\t\tscreenStates[screen.id][id] = state;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tfac.cleanUp();\n\t\t\treturn screenStates;\n\t\t},\n\n\t\tgetMatches(){\n\n\t\t\tthis.taskNames = {};\n\t\t\tif(this.testSettings){\n\n\t\t\t\tvar session = new DataFrame(this.events);\n\t\t\t\tsession = this.getActionEvents(session);\n\n\t\t\t\tvar tasks = this.testSettings.tasks;\n\t\t\t\tfor(var i=0; i < tasks.length; i++){\n\t\t\t\t\tthis.taskNames[tasks[i].id] = tasks[i].name;\n\t\t\t\t}\n\t\t\t\treturn this.analytics.getTaskPerformance(session, tasks, true);\n\n\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\tonBack(e){\n\t\t\tthis.stopEvent(e);\n\t\t\tthis.currentTime =0;\n\t\t\tthis.lastEventPos = 0;\n\t\t\tthis.setTime(0);\n\t\t},\n\n\t\tonPlay(e){\n\t\t\tthis.stopEvent(e);\n\n\t\t\t/**\n\t\t\t * make sure we start from the beginning after we have ended!\n\t\t\t */\n\t\t\tif(this.currentTime >= this.duration){\n\t\t\t\tthis.currentTime =0;\n\t\t\t\tthis.lastEventPos = 0;\n\t\t\t}\n\n\t\t\tif(!this.running){\n\t\t\t\tthis.start();\n\t\t\t} else {\n\t\t\t\tthis.stop();\n\t\t\t}\n\t\t},\n\n\t\tstart(){\n\t\t\tthis.running = true;\n\t\t\tcss.add(this.iconPlay, \"mdi-pause\");\n\t\t\tcss.remove(this.iconPlay, \"mdi-play\");\n\t\t\tthis.lastLoop = new Date().getTime();\n\t\t\trequestAnimationFrame(lang.hitch(this, \"loop\"));\n\t\t},\n\n\n\n\t\tstop(){\n\t\t\tthis.running = false;\n\t\t\tcss.remove(this.iconPlay, \"mdi-pause\");\n\t\t\tcss.add(this.iconPlay, \"mdi-play\");\n\t\t},\n\n\n\t\tloop(){\n\t\t\tvar now = new Date().getTime();\n\t\t\tvar dif = now - this.lastLoop;\n\t\t\tthis.lastLoop = now;\n\t\t\tthis.currentTime += dif;\n\n\n\t\t\tif(this.currentTime < this.duration){\n\t\t\t\tthis.setTime(this.currentTime);\n\t\t\t\tif(this.running){\n\t\t\t\t\trequestAnimationFrame(lang.hitch(this, \"loop\"));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// make sure we show the last event!\n\t\t\t\tthis.setTime(this.duration, true);\n\t\t\t\tthis.stop();\n\t\t\t}\n\n\t\t},\n\n\n\n\t\trender(){\n\t\t\tthis.logger.log(2,\"render\",\"enter\");\n\n\n\t\t\tthis.preview = this.$new(Preview, {isPlayer:true});\n\t\t\tthis.preview.setJwtToken(this.jwtToken)\n\t\t\tthis.preview.placeAt(this.previewWrapper);\n\t\t\tthis.preview.setModel(this.model);\n\n\t\t\tthis.scaledModel = this.preview.model;\n\n\t\t\tthis.slider = this.$new(HSlider);\n\t\t\tthis.slider.setMax(this.duration);\n\t\t\tthis.slider.setMarks(this.getAnnotation());\n\t\t\tthis.slider.placeAt(this.$refs.progress);\n\n\t\t\tthis.own(on(this.slider, \"change\", lang.hitch(this, \"onSliderChange\")));\n\t\t\tthis.renderEventList();\n\t\t\tthis.renderTaskBar()\n\t\t},\n\n\t\trenderPreview () {\n\t\t\tthis.$refs.container.innerHTML=\"\";\n\t\t\tvar previewWrapper = document.createElement(\"div\");\n\t\t\tcss.add(previewWrapper, \"MatcPlayerPreview\");\n\t\t\tthis.layout(previewWrapper);\n\t\t\treturn previewWrapper\n\t\t},\n\n\t\trenderTaskBar () {\n\t\t\tif(\tthis.taskMatches){\n\t\t\t\tconst tasks = this.taskMatches.as_dict('task')\n\t\t\t\tfor (let id in this.taskNames) {\n\t\t\t\t\tconst label = this.taskNames[id]\n\t\t\t\t\tlet row =  tasks[id]\n\t\t\t\t\tif (row) {\n\t\t\t\t\t\tconst start = (row.startTime - this.min) / this.duration\n\t\t\t\t\t\tconst length = (row.endTime - row.startTime) / this.duration\n\t\t\t\t\t\tthis.renderTask(start, length, label)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (Object.values(tasks).length === 0) {\n\t\t\t\t\tcss.add(this.$refs.tasks, \"MatcHidden\")\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\trenderTask (start, length, label) {\t\t\t\n\t\t\tconst bar = this.db\n\t\t\t\t.div('MatcPlayerTasksBarCntr')\n\t\t\t\t.div('MatcPlayerTasksBar', label)\n\t\t\t\t.build(this.$refs.tasks)\n\t\t\n\t\t\tbar.style.left = Math.min(97, (start * 100)) +'%'\n\t\t\tbar.style.width = Math.max(3, 100* length) +'%'\n\t\t},\n\n\n\t\tgetAnnotation(){\n\t\t\tconst result = [];\n\t\t\tif(\tthis.taskMatches){\n\t\t\t\tthis.taskMatches.foreach(row => {\n\t\t\t\t\tconst marker = {\n\t\t\t\t\t\tstart : row.startTime - this.min,\n\t\t\t\t\t\tlength : 0\n\t\t\t\t\t}\n\t\t\t\t\tresult.push(marker);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\n\t\trenderEventList(){\n\n\t\t\t/**\n\t\t\t * Merge in annotation.tags\n\t\t\t */\n\t\t\tvar list = [];\n\t\t\tfor(let i=0; i< this.events.length; i++){\n\t\t\t\tlet e = this.events[i];\n\t\t\t\tlist.push(e);\n\t\t\t}\n\t\t\tlist.sort(function(a,b){\n\t\t\t\treturn a.time - b.time;\n\t\t\t});\n\n\t\t\tthis.eventCntr.innerHTML=\"\";\n\t\t\tthis.cleanUpTempListener();\n\n\t\t\t// var scroller = new ScrollContainer();\n\t\t\t// scroller.placeAt(this.eventCntr);\n\n\t\t\tvar parent = document.createElement(\"div\");\n\n\t\t\tfor(let i=0; i< list.length; i++){\n\t\t\t\tlet e = list[i];\n\t\t\t\tlet type = e.type;\n\t\t\t\tif(type){\n\n\t\t\t\t\tif(!this.invisibleEvents[type] && !e.hidden){\n\t\t\t\t\t\tvar item = document.createElement(\"div\");\n\t\t\t\t\t\tcss.add(item, \"MatcPlayerEvent\");\n\t\t\t\t\t\tcss.add(item, e.type);\n\t\t\t\t\t\tvar txt = this.getMinute(e.time -this.min);\n\t\t\t\t\t\tif(type == \"WidgetClick\" || type == \"WidgetChange\" || type==\"ValidationError\" || type==\"ValidationErrorLine\"){\n\t\t\t\t\t\t\tif(e.state && (type == \"WidgetClick\" || type == \"WidgetChange\" )){\n\t\t\t\t\t\t\t\ttxt += \" - \" +  this.getEventStateLabel(e.state);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttxt += \" - \" + this.getEventLabel(e.type);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet widget = this.model.widgets[e.widget];\n\t\t\t\t\t\t\tif(widget){\n\t\t\t\t\t\t\t\ttxt +=\" -  &quot;\" + widget.name+\"&quot;\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttxt +=\" -  &quot;\" + e.widget +\"&quot;\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(type ==\"ScreenGesture\" && e.gesture){\n\t\t\t\t\t\t\tlet gesture = e.gesture;\n\t\t\t\t\t\t\tlet screen = this.model.screens[e.screen];\n\t\t\t\t\t\t\tif(screen){\n\t\t\t\t\t\t\t\ttxt += \" - Screen \" + this.getGestureLabel(gesture.type) + \" -  &quot;\" + screen.name +\"&quot;\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttxt += \" - Screen \" + this.getGestureLabel(gesture.type) + \" - &quot;\" + e.screen +\"&quot;\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t    } else if(type ==\"WidgetGesture\" && e.gesture){\n\t\t\t\t\t\t\tlet gesture = e.gesture;\n\t\t\t\t\t\t\tlet screen = this.model.screens[e.screen];\n\t\t\t\t\t\t\tif(screen){\n\t\t\t\t\t\t\t\ttxt += \" - \" + this.getGestureLabel(gesture.type) + \" -  &quot;\" + screen.name +\"&quot;\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttxt += \" - \" + this.getGestureLabel(gesture.type) + \" - &quot;\" + e.screen +\"&quot;\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet widget = this.model.widgets[e.widget];\n\t\t\t\t\t\t\tif(widget){\n\t\t\t\t\t\t\t\ttxt +=\" -  &quot;\" + widget.name+\"&quot;\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttxt +=\" -  &quot;\" + e.widget +\"&quot;\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t    } else {\n\t\t\t\t\t\t\tvar screen = this.model.screens[e.screen];\n\t\t\t\t\t\t\tif(screen){\n\t\t\t\t\t\t\t\ttxt += \" - \" + this.getEventLabel(e.type) + \" -  &quot;\" + screen.name +\"&quot;\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttxt += \" - \" + this.getEventLabel(e.type) + \" - &quot;\" + e.screen +\"&quot;\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\titem.innerHTML= this.stripHTML(txt);\n\t\t\t\t\t\tparent.appendChild(item);\n\t\t\t\t\t\tthis.tempOwn(on(item, touch.press, lang.hitch(this, \"onEvent\", e)));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet item = document.createElement(\"div\");\n\t\t\t\t\tcss.add(item, \"MatcPlayerEvent MatcPlayerTagEvent\");\n\t\t\t\t\tlet txt = this.getMinute(e.time -this.min) + \" - Tag &quot;\" + this.stripHTML( e.tag) + \"&quot;\";\n\t\t\t\t\titem.innerHTML=  txt;\n\t\t\t\t\tparent.appendChild(item);\n\t\t\t\t\tthis.tempOwn(on(item, touch.press, lang.hitch(this, \"onEvent\", e)));\n\n\t\t\t\t\tlet del = document.createElement(\"span\");\n\t\t\t\t\tcss.add(del, \"mdi mdi-close-circle MatcPlayerEventRemove\");\n\t\t\t\t\titem.appendChild(del);\n\t\t\t\t\tthis.tempOwn(on(del, touch.press, lang.hitch(this, \"removeTag\", e)));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tthis.eventCntr.appendChild(parent)\n\t\t},\n\n\t\tlayout(previewWrapper){\n\t\t\tconst container = this.$refs.container\n\n\t\t\tconst cPos = domGeom.position(container);\n\t\t\tconst pos = this.getScaledSize(cPos, \"auto\", this.model);\n\n\t\t\tpreviewWrapper.style.width = Math.round(pos.w) + \"px\";\n\t\t\tpreviewWrapper.style.height = pos.h + \"px\";\n\t\t\tcontainer.style.height = pos.h + \"px\";\n\t\t\tcontainer.appendChild(previewWrapper);\n\n\t\t\tconst domPos = domGeom.position(this.domNode);\n\t\t\tthis.eventCntr.style.height= Math.floor(domPos.h) + \"px\";\n\n\t\t\n\n\t\t\tif (this.dialog) {\n\t\t\t\tthis.logger.log(-1,'layout', 'dialog >> ' +  domPos.h + ' x ' +  domPos.w)\n\t\t\t\tdomPos.w += 0\n\t\t\t\tdomPos.h += 0\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.dialog.resize(domPos)\n\t\t\t\t}, 30)\n\t\t\t}\t\t\n\t\t},\n\n\t\tonEvent(e){\n\t\t\tthis.currentTime = e.time - this.min;\n\t\t\tthis.lastEventPos = 0;\n\t\t\tthis.preview.resetAnimations();\n\t\t\tthis.setTime(this.currentTime, true);\n\t\t},\n\n\n\n\t\tonSliderChange(v){\n\t\t\tthis.currentTime = v;\n\t\t\tthis.lastEventPos = 0;\n\t\t\tthis.preview.resetAnimations();\n\t\t\tthis.setTime(v, true);\n\t\t},\n\n\t\t/**\n\t\t * Render of time t (which is relative to the end. Dunno why I did that...)\n\t\t */\n\t\tsetTime(t, forceMarker){\n\n\t\t\t/**\n\t\t\t * The widget might already be destroyed....\n\t\t\t */\n\t\t\tif(!this.time){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Show the time\n\t\t\t */\n\t\t\tthis.time.innerHTML = this.getMinute(t) + \" / \" + this.getMinute(this.duration)  + \"\";\n\t\t\tthis.slider.setValue(t);\n\n\n\t\t\t/**\n\t\t\t * Now get the event\n\t\t\t */\n\t\t\tvar event = this.getEvent(Math.floor(t));\n\n\n\t\t\ttry {\n\t\t\t\t/**\n\t\t\t\t * Set screen or animate transition\n\t\t\t\t */\n\t\t\t\tif(event.screen){\n\n\t\t\t\t\tif(\"ScreenAnimation\" == event.type){\n\t\t\t\t\t\tthis.preview.animateScreen(event, t, this.min);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.preview.setScreen(event.screen, event.scrollTop);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Set overlays.\n\t\t\t\t *\n\t\t\t\t * 1) We render all overlays.\n\t\t\t\t * 2) Then we run an animation if required\n\t\t\t\t */\n\t\t\t\tvar overlays = this._overLayStates[event.id];\n\t\t\t\tif(overlays){\n\t\t\t\t\tthis.preview.setOverlays(overlays);\n\t\t\t\t}\n\t\t\t\tif(event.type == \"OverlayShowAnimation\" || event.type == \"OverlayRemoveAnimation\"){\n\n\t\t\t\t\tthis.preview.animateOverlay(event, t, this.min);\n\n\t\t\t\t} else if(this.lastEvent && this.lastEvent.type == \"OverlayShowAnimation\"){\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Because of skipping or so, the animation might not have reached 100%,\n\t\t\t\t\t * so we force fore the animation one mo time,\n\t\t\t\t\t */\n\t\t\t\t\tthis.preview.animateOverlay(this.lastEvent, t, this.min);\n\t\t\t\t}\n\n\n\t\t\t\t/**\n\t\t\t\t * Show a click marker. We only show the marker if the delta is small\n\t\t\t\t * and there and x and y values\n\t\t\t\t */\n\t\t\t\tvar tDelta = 0;\n\t\t\t\tif(forceMarker){\n\t\t\t\t\ttDelta = Math.abs((event.time -this.min) - t);\n\t\t\t\t}\n\t\t\t\tif(event.x> 0 && event.y >0 && tDelta < 100){\n\t\t\t\t\tthis.preview.setMarker(event, forceMarker );\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * now update widget states\n\t\t\t\t */\n\t\t\t\tvar states = this._widgetStates[event.id];\n\t\t\t\tfor(var widgetID in states){\n\t\t\t\t\tvar state = states[widgetID];\n\t\t\t\t\tthis.preview.setWidgetState(widgetID, state, forceMarker, t +this.min);\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Set scroll\n\t\t\t\t */\n\t\t\t\tthis.setScroll(event, t);\n\n\t\t\t\tthis.setMouseCursor(event, t);\n\n\n\t\t\t\t/**\n\t\t\t\t * fire widget animations\n\t\t\t\t */\n\n\t\t\t\tvar at = this.getAnimationIndex(t);\n\t\t\t\tif(this._widgetAnimationStates[at]){\n\t\t\t\t\tvar animStates = this._widgetAnimationStates[at];\n\t\t\t\t\tthis.preview.setWidgetAnimationStates(animStates);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(\"setTime() > No animation data for time index\", at)\n\t\t\t\t}\n\n\t\t\t} catch (err) {\n\t\t\t\tconsole.warn(\"VideoPlayer.setTime() > Error\", err)\n\t\t\t}\n\t\t\t\n\n\t\t\tthis.lastEventID = event.id;\n\n\t\t\tthis.lastEvent = event;\n\t\t},\n\n\n\t\tsetMouseCursor(event, t){\n\t\t\tvar i  = this.getAnimationIndex(t);\n\n\t\t\tif(this._mouseStates && this._mouseStates[i]){\n\t\t\t\tthis.preview.setMouse(this._mouseStates[i]);\n\t\t\t}\n\n\n\t\t},\n\n\t\tsetScroll(event, t){\n\n\t\t\tvar scrollState = this._scrollStates[event.id];\n\t\t\tif(scrollState){\n\t\t\t\tif(scrollState.children){\n\t\t\t\t\tif(!scrollState._ts){\n\t\t\t\t\t\tscrollState._scrollts = this.createTimeSeries(scrollState.children)\n\t\t\t\t\t}\n\t\t\t\t\tt = t + this.min;\n\t\t\t\t\tvar scrollEvent = scrollState._scrollts.get(t); //this._getLastValueForTime(scrollState.children, t);\n\t\t\t\t\tif(scrollEvent){\n\t\t\t\t\t\tthis.preview.setScroll(scrollEvent.value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.debug(\"setScroll()> No scrollEvent for event \", t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.preview.setScroll(scrollState.value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn(\"setScroll() > No scrollState for \", event.id);\n\t\t\t}\n\n\n\t\t},\n\n\t\t_getLastValueForTime(values, t){\n\t\t\tvar result = null;\n\t\t\tif(values){\n\t\t\t\t/**\n\t\t\t\t * we now the list is ordered. So we could use binay search, and save also the last position...\n\t\t\t\t */\n\t\t\t\tfor(var i=0; i< values.length; i++){\n\t\t\t\t\tvar value = values[i];\n\t\t\t\t\tif(value.time <= t) {\n\t\t\t\t\t\tresult = value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn(\"_getLastValueForTime() > No values passed\");\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\n\n\t\t/**\n\t\t * This method will return the event for the time stamp. It has a little tweak that it will start from the\n\t\t * last position, so that in theory we should have in the animation loop only 1 or 2 iterations in the loop.\n\t\t * However when clicking on the slider we have to set the lastEventPos to 0 so that we search all the array.\n\t\t */\n\t\tgetEvent(t){\n\t\t\tvar event = null;\n\t\t\tfor(var i= this.lastEventPos; i < this.events.length; i++){\n\t\t\t\tvar e = this.events[i];\n\t\t\t\tvar time = e.time - this.min;\n\t\t\t\tif(time > t){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = e;\n\t\t\t\tthis.lastEventPos = i;\n\t\t\t}\n\t\t\treturn event;\n\t\t},\n\n\n\t\tgetMinute(t){\n\t\t\tvar s = Math.round(t/1000);\n\t\t\tvar min = Math.floor(s / 60);\n\t\t\tvar sec = s % 60;\n\t\t\tif(sec < 10){\n\t\t\t\tsec = \"0\"+sec;\n\t\t\t}\n\t\t\treturn min+\":\"+sec;\n\t\t}\n    },\n    mounted () {\n    }\n}\n</script>","import mod from \"-!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./VideoPlayer.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./VideoPlayer.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./VideoPlayer.vue?vue&type=template&id=3d9bb06a\"\nimport script from \"./VideoPlayer.vue?vue&type=script&lang=js\"\nexport * from \"./VideoPlayer.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"names":["render","staticRenderFns","name","mixins","data","defaultRadius","defaultBlur","defaultGradient","max","components","methods","computeMouseDistribution","screens","temp","x","y","t","tDif","console","m","lastT","result","values","computeClickDistribution","_matrixToData","pos","cleanUpHeat","draw","ctx","p","minOpacity","radius","blur","circle","gradient","canvas","_colorize","j","pixels","computeScrollDurationDistrubtion","lastEventTime","lastScrollTop","scrollTop","computeScrollVisibiltyDistribution","lastPageLoad","pageSessions","drawSections","width","height","dist","lastY","lastValue","mounted","component","_vm","this","_h","$createElement","_c","_self","staticClass","ref","_m","attrs","props","running","currentTime","lastEventPos","animationTimeOffSet","mode","invisibleEvents","postCreate","init","setMouse","setTestSettings","setDialog","setModel","initSize","setSession","session","nextEvent","event","initMouseData","screen","time","dur","mouseStates","maxMouse","initAnimations","lastState","lastPos","lastScreenLoadTimeStamp","widgetInited","widgetInitedPos","fromPos","toPos","startTimeStamp","mixed","mixedPos","animationEnded","getAbsolutePosition","w","h","initWidgetAnimation","orginalStyle","style","initWidgetAnimationPos","start","originalPos","initWidgetStatesAndScroll","type","value","widgetStatesByEvent","lastStates","states","screenScoll","lastScroll","state","overLays","overlayStatesByEvent","_setStates","s","getDefaultStates","fac","screenStates","getMatches","onBack","onPlay","css","requestAnimationFrame","stop","loop","isPlayer","renderPreview","renderTaskBar","renderTask","div","build","bar","getAnnotation","length","renderEventList","list","txt","item","parent","layout","previewWrapper","container","domPos","setTimeout","onEvent","onSliderChange","setTime","tDelta","setMouseCursor","setScroll","scrollState","_getLastValueForTime","getEvent","getMinute","sec"],"sourceRoot":""}